mod mirror;

use self::mirror::Mirror;
use crate::opts;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::{cmp, fs, io};

#[derive(Debug, Serialize, Deserialize)]
pub struct MirrorList {
    pub cutoff: u32,
    pub last_check: String,
    pub num_checks: u8,
    pub check_frequency: u16,
    pub urls: Vec<Mirror>,
    pub version: u8,
}

impl MirrorList {
    pub fn get(url: &str) -> Result<Self, reqwest::Error> {
        let mut req: Self = if let Ok(cache) = fs::read_to_string("mirrors.cache") {
            serde_json::from_str(&cache).unwrap()
        } else {
            reqwest::blocking::get(url)?.json()?
        };

        req.urls.retain(|m| m.last_sync.is_some());
        Ok(req)
    }

    pub fn sort(&mut self, sorter: &opts::Sort) {
        use opts::Sort::*;
        match sorter {
            Age => self.sort_by_age(),
            Score => self.sort_by_score(),
        }
    }

    fn sort_by_age(&mut self) {
        self.urls.sort_unstable_by_key(|k| {
            let key = k
                .last_sync
                .as_ref()
                .unwrap()
                .parse::<DateTime<Utc>>()
                .unwrap();
            cmp::Reverse(key)
        });
    }

    fn sort_by_score(&mut self) {
        self.urls
            .sort_unstable_by(|a, b| b.score.partial_cmp(&a.score).unwrap())
    }

    fn build_output(&self, num: usize) -> String {
        let info = "# generated by rorrim";
        let date = Utc::now().format("# %C-%b-%Y at %H:%M:%S UTC");
        format!(
            "{info}\n{date}\n\n{}\n",
            self.urls
                .iter()
                .take(num)
                .map(|mirror| mirror.to_string())
                .collect::<Vec<String>>()
                .join("\n")
        )
    }

    pub fn save(&self, num: usize, out: &mut dyn io::Write) -> io::Result<()> {
        let output = self.build_output(num);
        out.write_all(output.as_bytes())
    }
}

/* WIP: Implemenation of caching without impacting actual program runtime by syncing cache when
MirrorList is dropped */

/* impl Drop for MirrorList {
    fn drop(&mut self) {
        if let Ok(mut file) = fs::File::create("mirrors.cache") {
            let _ = file.write_all(serde_json::to_string(&self).unwrap().as_bytes());
        }
    }
} */
