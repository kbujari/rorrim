mod mirror;

use self::mirror::Mirror;
use crate::opts;
use chrono::{DateTime, Utc};
use serde::Deserialize;
use std::{cmp, env, fs, io};

#[derive(Debug, Deserialize)]
pub struct MirrorList {
    pub cutoff: u32,
    pub last_check: String,
    pub num_checks: u8,
    pub check_frequency: u16,
    pub urls: Vec<Mirror>,
    pub version: u8,
}

impl MirrorList {
    pub fn get(url: &str) -> Result<Self, reqwest::Error> {
        let cache_path = env::temp_dir().join("mirrors.cache");

        let mut req: Self = match fs::read_to_string(cache_path) {
            Ok(cache) => serde_json::from_str(&cache).unwrap(),
            Err(_) => reqwest::blocking::get(url)?.json()?,
        };

        req.urls.retain(|mirror| mirror.last_sync.is_some());
        Ok(req)
    }

    pub fn sort(&mut self, sorter: &opts::Sort) {
        use opts::Sort::*;
        match sorter {
            Age => self.sort_by_age(),
            Score => self.sort_by_score(),
        }
    }

    fn sort_by_age(&mut self) {
        self.urls.sort_unstable_by_key(|k| {
            let key = k
                .last_sync
                .as_ref()
                .unwrap()
                .parse::<DateTime<Utc>>()
                .unwrap();
            cmp::Reverse(key)
        });
    }

    fn sort_by_score(&mut self) {
        self.urls
            .sort_unstable_by(|a, b| a.score.partial_cmp(&b.score).unwrap())
    }

    fn build_output(&self, num: usize) -> String {
        let info = "# generated by rorrim";
        let date = Utc::now().format("# %C-%b-%Y at %H:%M:%S UTC");

        let output =
            self.urls
                .iter()
                .take(num)
                .map(Mirror::to_string)
                .fold(String::new(), |mut a, b| {
                    a.reserve(b.len() + 1);
                    a.push_str(b.as_str());
                    a.push('\n');
                    a
                });

        format!("{info}\n{date}\n\n{output}")
    }

    pub fn save(&self, num: usize, mut out: impl io::Write + 'static) -> io::Result<()> {
        let output = self.build_output(num);
        out.write_all(output.as_bytes())
    }
}

/* WIP: Implemenation of caching without impacting actual program runtime by syncing cache when
MirrorList is dropped */

/* impl Drop for MirrorList {
    fn drop(&mut self) {
        if let Ok(mut file) = fs::File::create(CACHE_PATH) {
            let _ = file.write_all(serde_json::to_string(&self).unwrap().as_bytes());
        }
    }
} */
