use self::cli::MIRROR_NUM;
use self::request::Mirror;
use chrono::prelude::*;
use std::{fs, io::Write, path::PathBuf};

mod cli;
mod request;

fn write_file(path: &PathBuf, mirrors: &Vec<&Mirror>) -> Result<(), std::io::Error> {
    let info = "# generated by rorrim";
    let date = Utc::now().format("# %v at %H:%M:%S UTC");
    let output = mirrors
        .iter()
        .map(|mirror| format!("Server = {}$repo/os/$arch", mirror.url))
        .collect::<Vec<String>>()
        .join("\n");

    fs::File::create(path)?
        .write_all(format!("{}\n{}\n\n{}", info, date, output).as_bytes())?;
    Ok(())
}

fn main() -> Result<(), &'static str>{
    let args = <cli::Args as clap::Parser>::parse();

    let req = match request::get_mirrors(&args.url, &args.use_cache){
        ok
    };

    // use local file for testing
    // let req: Request = serde_json::from_str(&fs::read_to_string("sample.json").unwrap()).unwrap();

    let mut mirrors: Vec<&Mirror> = req
        .urls
        .iter()
        .filter(|x| {
            args.country.contains(&x.country)
                && args
                    .protocol
                    .iter()
                    .map(|x| x.to_string())
                    .any(|n| n == x.protocol)
                && args.no_iso
                && args.no_ipv4
                && args.no_ipv6
        })
        .take({
            match args.number {
                Some(num) => num.into(),
                None => MIRROR_NUM.into(),
            }
        })
        .collect();

    mirrors.sort_by(|a, b| {
        a.score
            .partial_cmp(&b.score)
            .expect("Error sorting mirrors by score")
    });

    match args.save {
        Some(path) => write_file(&path, &mirrors).unwrap(),
        None => mirrors
            .iter()
            .for_each(|mirror| println!("Server = {}$repo/os/$arch", mirror.url)),
    };
    Ok(())
}
