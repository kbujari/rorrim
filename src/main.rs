mod mirrors;
mod opts;

use chrono::Utc;
use clap::Parser;
use std::{fs, io};

use crate::mirrors::{Mirror, MirrorList};

const MIRROR_NUM: usize = 10;
const MIRROR_URL: &str = "https://archlinux.org/mirrors/status/json/";

fn push_output(mut out: impl io::Write, mirrors: Vec<Mirror>) -> io::Result<()> {
    let info = "# generated by rorrim";
    let date = Utc::now().format("# %C-%b-%Y at %H:%M:%S UTC");
    let output = format!("{info}\n{date}\n\n{}\n", {
        mirrors
            .iter()
            .map(|mirror| mirror.to_string())
            .collect::<Vec<String>>()
            .join("\n")
    });

    out.write_all(output.as_bytes())?;
    Ok(())
}

fn main() -> anyhow::Result<()> {
    let args = opts::Args::parse();

    let req: MirrorList = mirrors::get_mirrors(&args.url.unwrap_or(MIRROR_URL.to_string()))?;

    let mirrors = req
        .urls
        .into_iter()
        .filter(|m| args.country.contains(&m.country))
        .filter(|_| args.no_iso && args.no_ipv4 && args.no_ipv6)
        .filter(|m| {
            args.protocol
                .iter()
                .any(|proto| proto.to_string() == m.protocol)
        })
        .take(args.number.unwrap_or(MIRROR_NUM))
        .collect();

    if let Some(path) = args.save {
        let f = fs::File::create(path)?;
        push_output(f, mirrors)?;
    } else {
        push_output(io::stdout(), mirrors)?;
    };

    Ok(())
}
