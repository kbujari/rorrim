use crate::request::Mirror;
use chrono::prelude::*;
use std::{fs, io::Write, path::PathBuf};

mod cli;
mod request;

const MIRROR_NUM: usize = 10;
const MIRROR_URL: &'static str = "https://archlinux.org/mirrors/status/json/";

fn write_file(path: &Option<PathBuf>, mirrors: &Vec<&Mirror>) -> std::io::Result<()> {
    let info = "# generated by rorrim";
    let date = Utc::now().format("# %C-%b-%Y at %H:%M:%S UTC");
    let output = format!("{info}\n{date}\n\n{}\n", {
        mirrors
            .iter()
            .map(|mirror| mirror.to_string())
            .collect::<Vec<String>>()
            .join("\n")
    });

    match path {
        Some(p) => fs::File::create(p)?.write_all(output.as_bytes())?,
        None => print!("{output}"),
    };

    Ok(())
}

fn main() -> Result<(), &'static str> {
    let args = <cli::Args as clap::Parser>::parse();

    //let req = request::get_mirrors(&args.url.unwrap_or(MIRROR_URL.to_string())).unwrap();

    // use local file for testing
    let req: crate::request::Request =
        serde_json::from_str(&fs::read_to_string("sample.json").unwrap()).unwrap();

    let mirrors: Vec<&Mirror> = req
        .urls
        .iter()
        .filter(|mirror| {
            args.country.contains(&mirror.country)
                && args
                    .protocol
                    .iter()
                    .map(|m| m.to_string())
                    .any(|n| n == mirror.protocol)
                && args.no_iso
                && args.no_ipv4
                && args.no_ipv6
        })
        .take({
            match args.number {
                Some(num) => num,
                None => MIRROR_NUM,
            }
        })
        .collect();
    /*
    mirrors.sort_by(|a, b| {
        a.score
            .partial_cmp(&b.score)
            .expect("Error sorting mirrors by score")
    });
    */
    write_file(&args.save, &mirrors).unwrap();

    Ok(())
}
