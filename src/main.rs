use self::cli::{MIRROR_NUM, MIRROR_URL};
use self::request::{Mirror, Request};
use chrono::prelude::*;
use std::{fs, io::Write, path::PathBuf};

mod cli;
mod request;

fn write_file(path: &PathBuf, mirrors: &Vec<&Mirror>) {
    let date = Utc::now().format("%v at %H:%M:%S UTC");

    /*
    let mut file = match fs::File::create(path) {
        Ok(file) => file,
        Err(why) => panic!("Unable to open file {}: {:?}", path.display(), why),
    };
    */

    let mut file = fs::File::create(path).unwrap_or_else(|e| {
        eprintln!("Unable to open file {}: {}", path.display(), e);
        std::process::exit(1);
    });

    file.write_all(format!("# generated by rorrim \n# {}\n\n", date).as_bytes())
        .expect("Unable to write to file.");

    mirrors.iter().for_each(|mirror| {
        file.write_all(format!("Server = {}$repo/os/$arch\n", mirror.url).as_bytes())
            .expect("Unable to write to file.")
    });
}

fn main() {
    let args = <cli::Args as clap::Parser>::parse();

    /*
    let req: Request = match reqwest::blocking::get(MIRROR_URL) {
        Ok(req) => req.json().expect("Error converting request to JSON"),
        Err(why) => panic!("Retrieving mirrorlist failed from {}: {}", MIRROR_URL, why),
    };
    */

    // use local file for testing
    let req: Request = serde_json::from_str(&fs::read_to_string("sample.json").unwrap()).unwrap();

    let mut mirrors: Vec<&Mirror> = req
        .urls
        .iter()
        .filter(|x| {
            args.country.contains(&x.country)
                && args
                    .protocol
                    .iter()
                    .map(|x| x.to_str())
                    .any(|n| n == x.protocol)
                && args.no_iso
                && args.no_ipv4
                && args.no_ipv6
        })
        .take({
            match args.number {
                Some(num) => num.into(),
                None => MIRROR_NUM.into(),
            }
        })
        .collect();

    mirrors.sort_by(|a, b| {
        a.score
            .partial_cmp(&b.score)
            .expect("Error sorting mirrors by score")
    });

    match args.save {
        Some(path) => write_file(&path, &mirrors),
        None => mirrors
            .iter()
            .for_each(|mirror| println!("Server = {}$repo/os/$arch", mirror.url)),
    };
}
